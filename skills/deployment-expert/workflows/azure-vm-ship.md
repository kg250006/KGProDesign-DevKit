<required_reading>
Read references/azure-vm.md for SSH context.
Read the project's .deployment-profile.json for connection details.
</required_reading>

<overview>
## Ship to Production (Existing Azure VM App)

**Use this workflow when deployment infrastructure is already in place.**

This is the fast path: commit → PR → merge → **monitor** (don't intervene).

### Philosophy

1. **Monitor, don't intervene** - The auto-deploy process handles everything. We SSH in to watch, not to touch.
2. **Only intervene on failure** - If something breaks, we reassess and fix the **codebase**, not the VM.
3. **Never modify database directly** - All database changes go through migration scripts. Period.
4. **Migrations must complete** - Deployment isn't successful until migrations have run.

### Prerequisites (already done):
- `.deployment-profile.json` exists with `azureVm` config
- VM has auto-deploy cron job watching production branch
- Deploy scripts, Docker, NPM all configured
- SSH access working

If any of these are missing → route to `workflows/vm-auto-deploy-setup.md` instead.
</overview>

<quick_check>
## Pre-Flight (5 seconds)

Before starting, verify we're in "existing app" state:

```bash
# Check profile exists and has Azure VM config
if [[ -f ".deployment-profile.json" ]]; then
    PLATFORM=$(jq -r '.platform' .deployment-profile.json)
    if [[ "$PLATFORM" == "azure-vm" ]]; then
        # Extract connection details
        VM_HOST=$(jq -r '.azureVm.host' .deployment-profile.json)
        VM_USER=$(jq -r '.azureVm.user' .deployment-profile.json)
        SSH_KEY=$(jq -r '.azureVm.sshKeyPath // "~/.ssh/id_ed25519"' .deployment-profile.json)
        AUTH_METHOD=$(jq -r '.azureVm.authMethod // "ssh-key"' .deployment-profile.json)
        PROD_BRANCH=$(jq -r '.githubProduction.branch // "production"' .deployment-profile.json)
        APP_NAME=$(jq -r '.name // ""' .deployment-profile.json)

        echo "Ready to ship: $APP_NAME → $PROD_BRANCH → $VM_HOST"
    else
        echo "Profile exists but platform is $PLATFORM, not azure-vm"
        # Route to setup or different platform workflow
    fi
else
    echo "No deployment profile found"
    # Route to setup-profile.md
fi
```

**If profile missing or not azure-vm:** Stop and ask user if they want to set up deployment first.
</quick_check>

<process>
## Step 1: Check Local Status

```bash
# What's the current state?
echo "=== Current Branch ==="
git branch --show-current

echo "=== Uncommitted Changes ==="
git status --short

echo "=== Commits Ahead of Origin ==="
git log origin/$(git branch --show-current)..HEAD --oneline 2>/dev/null || echo "None"
```

**Ask user based on state:**

If uncommitted changes exist:
```
You have uncommitted changes:
[list files]

Options:
1. Commit these changes and ship to production
2. Stash changes and ship existing commits only
3. Cancel - I need to review first
```

If no changes and no unpushed commits:
```
No local changes to ship. Options:
1. Trigger a re-deploy of current production (useful for env var changes)
2. Check deployment status on VM
3. Cancel
```

## Step 2: Commit Changes (if needed)

```bash
# Stage all changes
git add -A

# Commit with conventional message
git commit -m "$(cat <<'EOF'
feat: [description from user or auto-generated]

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"

# Push to current branch (usually main)
git push origin $(git branch --show-current)
```

**Report:**
```
Committed and pushed to main:
- abc1234: feat: [description]
```

## Step 3: Create PR to Production (or Direct Merge)

**Check if PR workflow or direct merge:**
```bash
# Check if there's branch protection on production
# If yes, create PR. If no, can merge directly.

PROD_BRANCH=$(jq -r '.githubProduction.branch // "production"' .deployment-profile.json)
BASE_BRANCH=$(jq -r '.githubProduction.baseBranch // "main"' .deployment-profile.json)
```

**Option A: Create PR (recommended for teams/audit trail)**
```bash
# Create PR using GitHub CLI
gh pr create \
    --base "$PROD_BRANCH" \
    --head "$BASE_BRANCH" \
    --title "Deploy: $(git log -1 --format=%s)" \
    --body "$(cat <<'EOF'
## Deployment PR

Merging latest changes from main to production.

### Changes included:
$(git log origin/$PROD_BRANCH..origin/$BASE_BRANCH --oneline)

### Deployment
This will be auto-deployed to the VM via cron job monitoring the production branch.

---
Generated by deployment-expert skill
EOF
)"
```

**Option B: Direct merge (solo developer/fast path)**
```bash
# Checkout production, merge main, push
git fetch origin
git checkout "$PROD_BRANCH"
git merge "$BASE_BRANCH" --no-edit
git push origin "$PROD_BRANCH"
git checkout "$BASE_BRANCH"  # Return to main
```

**Ask user:**
```
Ready to deploy to production. Choose method:

1. Create PR to production (recommended - creates audit trail)
2. Direct merge to production (faster - no PR)
3. Cancel
```

## Step 4: Merge PR (if created)

If PR was created:
```bash
# Get PR number
PR_URL=$(gh pr list --base "$PROD_BRANCH" --head "$BASE_BRANCH" --json url -q '.[0].url')
PR_NUMBER=$(basename "$PR_URL")

# Merge the PR
gh pr merge "$PR_NUMBER" --merge --delete-branch=false

echo "PR #$PR_NUMBER merged to production"
```

## Step 5: SSH to VM and Monitor Deployment

**IMPORTANT: We are MONITORING only. Do not intervene unless deployment fails.**

**Connect and watch:**
```bash
# Build SSH command based on auth method
if [[ "$AUTH_METHOD" == "azure-ad" ]]; then
    # Azure AD SSH (if configured)
    SSH_CMD="az ssh vm --resource-group $RESOURCE_GROUP --name $VM_NAME"
else
    # Traditional SSH key
    SSH_KEY_EXPANDED="${SSH_KEY/#\~/$HOME}"
    SSH_CMD="ssh -i $SSH_KEY_EXPANDED $VM_USER@$VM_HOST"
fi

echo "Connecting to VM to monitor deployment..."
echo "Command: $SSH_CMD"
echo ""
echo "NOTE: We are monitoring only. Let the auto-deploy process work."
echo "      Only intervene if you see failures in the logs."
```

**On the VM, run monitoring commands:**
```bash
# Show current state first
echo "=== Current Deployment State ==="
echo "Local commit:  $(cd /opt/${APP_NAME} && git rev-parse --short HEAD)"
echo "Remote commit: $(cd /opt/${APP_NAME} && git rev-parse --short origin/production)"

# Check if cron has already picked up the change
if [[ "$(cd /opt/${APP_NAME} && git rev-parse HEAD)" == "$(cd /opt/${APP_NAME} && git rev-parse origin/production)" ]]; then
    echo "Status: Already up to date (cron may have already deployed)"
else
    echo "Status: Changes pending - cron will pick up within 5 minutes"
fi
echo ""

# Watch the auto-deploy log in real-time
echo "Watching deployment log (Ctrl+C to stop)..."
echo "Look for: 'AUTO-DEPLOYMENT COMPLETED SUCCESSFULLY' or errors"
echo ""
tail -f /opt/cron/logs/${APP_NAME}-deploy.log
```

**What to watch for in logs:**
```
SUCCESS indicators:
- "Changes detected! Updating from xxx to yyy"
- "Building images..."
- "Starting services..."
- "Running migrations..."
- "Migration completed successfully"    ← CRITICAL: Must see this
- "NPM reloaded successfully"
- "AUTO-DEPLOYMENT COMPLETED SUCCESSFULLY"

FAILURE indicators:
- "ERROR:" or "FAILED:"
- "Migration failed"                     ← STOP: Do not proceed
- "Health check failed"
- "Container exited with code 1"
- "Deployment failed! Failures: X/3"
```

**DO NOT manually trigger deploy unless:**
1. Cron hasn't run in 10+ minutes AND
2. You've verified cron is actually running (`grep CRON /var/log/syslog | tail -5`)

The auto-deploy system is designed to be hands-off. Trust it.

## Step 6: Verify Deployment Success

**Deployment is NOT complete until ALL of these pass:**

1. Docker containers healthy
2. Migrations completed successfully
3. NPM reloaded (auto-done by deploy script)
4. Health endpoints return 200

```bash
echo "=== Deployment Verification ==="

# 1. Container status
echo "Containers:"
docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Health}}' | grep ${APP_NAME}

# 2. CRITICAL: Verify migrations completed
echo ""
echo "Migration Status:"
docker logs ${APP_NAME}-backend-prod 2>&1 | grep -iE "(migration|alembic|migrate)" | tail -5
# Look for: "Migration completed" or "No migrations to run"
# FAILURE: "Migration failed" or "alembic.util.exc" errors

# 3. NPM reload (should be done by deploy script, but verify)
if docker ps --format '{{.Names}}' | grep -q "nginx-proxy-manager"; then
    docker exec nginx-proxy-manager nginx -t 2>&1 | tail -1
fi

# 4. HTTP health check
DOMAIN=$(jq -r '.verification.url // ""' /opt/${APP_NAME}/.deployment-profile.json 2>/dev/null | sed 's|https://||')
if [[ -n "$DOMAIN" ]]; then
    echo ""
    echo "Health Endpoints:"
    API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "https://${DOMAIN}/api/health")
    FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "https://${DOMAIN}/")
    echo "  API:      $API_STATUS"
    echo "  Frontend: $FRONTEND_STATUS"
fi

# Show deployed commit
echo ""
echo "Deployed commit: $(cd /opt/${APP_NAME} && git rev-parse --short HEAD)"
```

## Step 6b: If Deployment Failed - Intervention Protocol

**STOP. Do not try to fix things on the VM.**

If you see failures in the deployment:

### 1. Identify the failure type

```bash
# Check the deploy log for the error
tail -100 /opt/cron/logs/${APP_NAME}-deploy.log | grep -A5 -B5 "ERROR\|FAILED\|error\|failed"
```

### 2. Categorize the issue

| Failure Type | Fix Location | Action |
|--------------|--------------|--------|
| Migration failed | **Codebase** | Fix migration script, commit, re-deploy |
| Build failed | **Codebase** | Fix code/Dockerfile, commit, re-deploy |
| Container unhealthy | **Codebase** | Fix app code or health check, commit, re-deploy |
| Disk full | VM (exception) | `docker system prune -af` then re-trigger |
| NPM 502 | VM (exception) | `docker exec nginx-proxy-manager nginx -s reload` |
| SSH/cron issue | VM (exception) | Fix cron config, but document in codebase |

### 3. For codebase fixes:

```bash
# Exit the VM
exit

# Back on local machine:
# 1. Identify the fix needed
# 2. Make the fix in code
# 3. Commit and push
git add -A
git commit -m "fix: [description of deployment fix]"
git push origin main

# 4. Merge to production again
git checkout production
git merge main --no-edit
git push origin production
git checkout main

# 5. SSH back to monitor the new deployment
ssh -i ~/.ssh/key user@host "tail -f /opt/cron/logs/${APP_NAME}-deploy.log"
```

### 4. NEVER do this:

```bash
# NEVER modify database directly
psql -U postgres -d mydb -c "ALTER TABLE..."  # NO!
docker exec db psql -c "UPDATE users SET..."   # NO!

# NEVER edit code on the VM
vim /opt/${APP_NAME}/src/main.py  # NO!
nano /opt/${APP_NAME}/docker-compose.yml  # NO!

# NEVER run migrations manually (unless documented recovery procedure)
docker exec backend alembic upgrade head  # NO! Let deploy script handle it
```

**All fixes go through the codebase → commit → deploy cycle.**

## Step 7: Report Final Status

**Success output:**
```
════════════════════════════════════════════════════
DEPLOYMENT COMPLETE
════════════════════════════════════════════════════

App:        {app-name}
Branch:     production
Commit:     abc1234
VM:         {vm-host}
Status:     LIVE

Health Check:
  API:      200 OK
  Frontend: 200 OK

Containers:
  {app}-backend-prod   Up 30 seconds (healthy)
  {app}-frontend-prod  Up 25 seconds (healthy)

URL: https://{domain}

════════════════════════════════════════════════════
```

**Failure output:**
```
════════════════════════════════════════════════════
DEPLOYMENT ISSUE DETECTED
════════════════════════════════════════════════════

Status: Health check returned 502

Likely cause: NPM DNS cache stale after container rebuild

Quick fix (run on VM):
  docker exec nginx-proxy-manager nginx -s reload

Or run full troubleshooting:
  /deploy troubleshoot

════════════════════════════════════════════════════
```
</process>

<interactive_mode>
## Interactive SSH Session

If user wants to stay connected to monitor:

```bash
# Keep SSH session open with useful prompt
echo "Connected to $VM_HOST as $VM_USER"
echo ""
echo "Quick commands:"
echo "  logs     - Tail deployment logs"
echo "  status   - Container status"
echo "  health   - Run health check"
echo "  reload   - Reload NPM"
echo "  deploy   - Trigger manual deploy"
echo "  exit     - Disconnect"
echo ""

# Define aliases for the session
alias logs="tail -50 /opt/cron/logs/${APP_NAME}-deploy.log"
alias status="docker ps --format 'table {{.Names}}\t{{.Status}}' | grep ${APP_NAME}"
alias health="curl -sf https://${DOMAIN}/api/health && echo 'OK' || echo 'FAILED'"
alias reload="docker exec nginx-proxy-manager nginx -s reload"
alias deploy="/opt/cron/jobs/auto-deploy-${APP_NAME}.sh"
```
</interactive_mode>

<one_liner>
## One-Liner Version (for experienced users)

If user just says "ship it" with no elaboration:

```bash
# Commit, push, merge to production, trigger deploy, verify
git add -A && \
git commit -m "feat: updates" && \
git push origin main && \
git checkout production && \
git merge main --no-edit && \
git push origin production && \
git checkout main && \
ssh -i ~/.ssh/kgp_vm_deploy user@host "/opt/cron/jobs/auto-deploy-app.sh && sleep 30 && curl -sf https://domain/api/health"
```

This entire flow can complete in under 60 seconds for small changes.
</one_liner>

<error_handling>
## Common Issues During Ship

| Issue | Symptom | Fix |
|-------|---------|-----|
| SSH fails | Permission denied | Check `.deployment-profile.json` for correct `authMethod` and `sshKeyPath` |
| PR creation fails | "no commits between" | Main and production already in sync, nothing to deploy |
| Deploy script fails | Exit code 1 | Check `/opt/cron/logs/{app}-deploy.log` for details |
| 502 after deploy | Bad Gateway | Run `docker exec nginx-proxy-manager nginx -s reload` |
| Cron not triggering | No log activity | Check `crontab -l` and `/var/log/syslog | grep CRON` |

**If SSH auth method is wrong:**
```
CRITICAL: Check the deployment profile first!

cat .deployment-profile.json | jq '.azureVm.authMethod, .azureVm.sshKeyPath, .azureVm.host, .azureVm.user'

If authMethod is "ssh-key": use ssh -i {keyPath} user@host
If authMethod is "azure-ad": use az ssh vm --resource-group {rg} --name {vm}
```
</error_handling>

<success_criteria>
## Ship is successful when:

**Git/CI Phase:**
- [ ] Changes committed to main
- [ ] Main merged to production (via PR or direct)
- [ ] Production branch pushed to origin

**Auto-Deploy Phase (monitor only):**
- [ ] VM cron detected changes (seen in deploy log)
- [ ] Docker build completed successfully
- [ ] **Migrations completed successfully** ← CRITICAL
- [ ] Containers started and healthy
- [ ] NPM reloaded (done by deploy script)

**Verification Phase:**
- [ ] Health endpoints return 200
- [ ] No errors in container logs
- [ ] User sees final status report

**Ship is NOT successful if:**
- Migrations failed or didn't run
- Containers show "unhealthy" status
- Health check returns non-200
- Deploy log shows "FAILED" or circuit breaker triggered
</success_criteria>

<database_rules>
## Database Golden Rules

1. **NEVER modify the database directly** - not via psql, not via admin panel, not via any means
2. **All schema changes go through migrations** - Alembic, Prisma, Django migrations, etc.
3. **All data fixes go through migrations** - data migrations are migrations too
4. **Migrations must be idempotent** - safe to run multiple times
5. **Migrations must be tested locally first** - before committing
6. **Rollback migrations must exist** - for every up, there's a down

**If you need to fix data in production:**
```python
# Create a data migration, not a manual SQL command
# alembic revision -m "fix_user_email_typo"

def upgrade():
    op.execute("UPDATE users SET email = 'correct@example.com' WHERE id = 123")

def downgrade():
    op.execute("UPDATE users SET email = 'typo@example.com' WHERE id = 123")
```

Then commit, push, merge to production, and let the deploy process run it.
</database_rules>
